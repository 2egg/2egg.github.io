<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>2egg</title>
  
  <subtitle>2egg的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2egg.github.io/"/>
  <updated>2020-07-29T16:00:00.000Z</updated>
  <id>https://2egg.github.io/</id>
  
  <author>
    <name>HLJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网站搜索引擎收录</title>
    <link href="https://2egg.github.io/2019/07/30/%E7%BD%91%E7%AB%99%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95/"/>
    <id>https://2egg.github.io/2019/07/30/网站搜索引擎收录/</id>
    <published>2019-07-30T08:54:11.000Z</published>
    <updated>2020-07-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>搜索引擎快照，是指在访客在无法打开某个搜索结果，或者打开速度特别慢的情况下，为访客提供的之前保存在搜索引擎服务器上对应网页内容的纯文本。不过，搜索引擎保存的快照内容一般只包括文本数据，图片及其他多媒体等非文本数据不会被保存。因此，在来源网站无法访问的情况下，图片及其他多媒体在快照中将无法显示。</p><footer><strong>百度百科</strong><cite><a href="https://baike.baidu.com/item/快照/327038" target="_blank" rel="noopener">baike.baidu.com/item/快照/327038</a></cite></footer></blockquote><ol><li><p>百度</p><ol><li>登陆注册<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度搜索资源资源平台</a></li><li>进入用户中心-站点管理-添加网站</li><li>勾选网站属性</li><li>验证网站（下载验证文件<u><em>baidu_verify_<em>**</em>.html</em></u> 存放至域名根目录下 测试该文件是否可以访问,最后点击完成验证.）</li><li>验证之后点击该网站链接 可以看到所有网站关于搜索的情况</li><li>点击搜索展现-HTTPS认证（需要保证全站所有链接都支持HTTPS访问）</li><li>验证成功之后再次搜索就基本可以看到了（但是具体的文章还没弄好）</li></ol></li><li><p>谷歌</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;搜索引擎快照，是指在访客在无法打开某个搜索结果，或者打开速度特别慢的情况下，为访客提供的之前保存在搜索引擎服务器上对应网页内容的纯文本。不过，搜索引擎保存的快照内容一般只包括文本数据，图片及其他多媒体等非文本数据不会被保存。因此，在来源网站无法访问的
      
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="https://2egg.github.io/2019/06/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://2egg.github.io/2019/06/23/负载均衡/</id>
    <published>2019-06-23T03:20:35.000Z</published>
    <updated>2019-07-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>​    多台服务器组成一台服务器集合，每台服务器都具有等价的地位， 可以单独提供服务且无需其他服务器的辅助，通过某种负载分担技术，将外部发送来的请求 均衡的分配到服务器集合中的每一台服务器上，而接受到请求的服务器独立的回应客户请求。 </p><a id="more"></a><p>​    负载均衡是高可用网络基础架构的一个关键组成部分， 有了负载均衡，我们通常可以将我们的应用服务器部署多个，然后通过负载均衡将用户的请求发送到不同的服务器来提高网站，应用，数据库或者其他服务的性能以及可靠性。</p><p>​    正常情况下多个用户通过网络 访问单个服务器，数据库处理数据，如果出现服务器宕机的情况的话，在只有一个服务器的下，用户的请求就会得不到回应（单点故障问题），又或者N个用户在段时间内访问同一服务器，超过了服务器的处理能力，会产生响应速度慢 甚至无法连接到服务器的情况。</p><h5 id="负载均衡方案"><a href="#负载均衡方案" class="headerlink" title="负载均衡方案"></a>负载均衡方案</h5><p>​    通过一个负载均衡器、至少两个web服务器、由 均衡器根据业务逻辑（比如：某个服务器通过运行状态检查服务检查此服务器已经宕机，将不分配用户请求给此服务器，直至检查服务器状态为”健康”在将用户请求发送给此服务器。）分配用户请求转发至某个服务器。</p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ip列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ipMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; serverWeightMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.100"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.101"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 权重为4</span></span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.102"</span>, <span class="number">4</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.103"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.104"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 权重为3</span></span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.105"</span>, <span class="number">3</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.106"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 权重为2</span></span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.107"</span>, <span class="number">2</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.108"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.109"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.110"</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h6><p>向集合中添加负载地址 加权 添加单个负载地址个数  随机负载个数，循环转发请求到服务器上，次数足够多的的情况下，每个负载地址根据权重所接受的请求次数 与集合长度是成比例的。</p><ul><li>优点：使用简单</li><li>缺点：不适合机器配置不同的场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 重建一个Map，避免服务器的上下线导致的并发问题</span></span><br><span class="line">       Map&lt;String, Integer&gt; serverMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">       serverMap.putAll(ipMap.serverWeightMap);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 取得Ip地址List</span></span><br><span class="line">       Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">       Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; serverList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           String server = iterator.next();</span><br><span class="line">           <span class="keyword">int</span> weight = serverMap.get(server);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++)</span><br><span class="line">               serverList.add(server);</span><br><span class="line">       &#125;</span><br><span class="line">       java.util.Random random = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">       <span class="keyword">int</span> randomPos = random.nextInt(serverList.size());</span><br><span class="line">       <span class="keyword">return</span> serverList.get(randomPos);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h6><p>为第一个请求选择健康池中的第一个后端服务器，然后按顺序往后依次选择，直到最后一个，然后循环。</p><ul><li>优点：服务器请求数目相同</li><li>缺点：服务器压力不一致，不合适服务器配置不同的情况；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pollingIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重建一个Map，避免服务器的上下线导致的并发问题</span></span><br><span class="line">        Map&lt;String, Integer&gt; serverMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        serverMap.putAll(ipMap.serverWeightMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得Ip地址List</span></span><br><span class="line">        Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; serverList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String server = iterator.next();</span><br><span class="line">            <span class="keyword">int</span> weight = serverMap.get(server);</span><br><span class="line">            <span class="comment">/*循环获取map 中的key 的value 是多少 放入list中 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++)</span><br><span class="line">                serverList.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">        String server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (pos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt; keySet.size())</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            server = serverList.get(pos);</span><br><span class="line">            pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="最小连接"><a href="#最小连接" class="headerlink" title="最小连接"></a>最小连接</h6><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有 快有慢，它正是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能地提高后端服务器的利用效率，将负载 合理地分流到每一台机器。由于最小连接数设计服务器连接数的汇总和感知，设计与实现较为繁琐。</p><ul><li>优点：根据服务器当前的情况处理请求，动态分配</li><li>缺点：算法实现相对复杂，需要监控服务器请求连接数；</li></ul><h6 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h6><p>根据请求源的某一值(IP)的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器，可以考虑采取这种方式。</p><ul><li>优点：将来自同一ip地址的请求，同一会话期内，转发到相同的服务器，直到后端服务器列表变更， 根据此特性 可以在服务先飞这与服务提供者之间建立有状态的session会话 实现会话粘贴。</li><li>缺点：某一目标服务器宕机后，当前服务器会话消失，出现hash倾斜</li></ul><p>出现hash倾斜的解决方案：虚拟节点，在真实的服务器节点之间 添加 添加服务器节点映射(虚拟节点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hash</span><span class="params">(String remoteIp)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 重建一个Map，避免服务器的上下线导致的并发问题</span></span><br><span class="line">       Map&lt;String, Integer&gt; serverMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">       serverMap.putAll(ipMap.serverWeightMap);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 取得Ip地址List</span></span><br><span class="line">       Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">       ArrayList&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       keyList.addAll(keySet);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 在Web应用中可通过HttpServlet的getRemoteIp方法获取</span></span><br><span class="line">       <span class="comment">//String remoteIp = "127.0.0.1";</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> hashCode = remoteIp.hashCode();</span><br><span class="line">       <span class="keyword">int</span> serverListSize = keyList.size();</span><br><span class="line">       <span class="keyword">int</span> serverPos = hashCode % serverListSize;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> keyList.get(serverPos);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h5><p>实际项目中的话肯定是多个均衡算法糅合在一起实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h5&gt;&lt;p&gt;​    多台服务器组成一台服务器集合，每台服务器都具有等价的地位， 可以单独提供服务且无需其他服务器的辅助，通过某种负载分担技术，将外部发送来的请求 均衡的分配到服务器集合中的每一台服务器上，而接受到请求的服务器独立的回应客户请求。 &lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Liskov Substitution Principle - 里氏代换原则</title>
    <link href="https://2egg.github.io/2019/05/05/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>https://2egg.github.io/2019/05/05/里氏代换原则/</id>
    <published>2019-05-05T06:54:37.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="里氏代换原则-——-LSP"><a href="#里氏代换原则-——-LSP" class="headerlink" title="里氏代换原则 —— LSP"></a>里氏代换原则 —— LSP</h2><blockquote><p>任何基类可以出现的地方，子类一定可以出现！</p></blockquote><p>&emsp;&emsp;里氏替换原则，OCP作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将<strong>设计中的静态结构改为动态结构，维持设计的封闭性</strong>。“抽象”是语言提供的功能。“多态”由继承语义实现。<br><a id="more"></a><br>里氏替换原则包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li><li>子类可以增加自己特有的方法。</li><li>当子类覆盖或者实现父类的方法时，方法的前置条件（方法的形象）要比父类的方法输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值） 要比父类的更加严谨。</li></ul><p>&emsp;&emsp;LSP 一个软件如果使用的是一个父类的话， 那么一定适用于其子类， 而察觉不出父类对象和子类对象的区别。 也即是说，在软件里面，<strong> 把父类替换成它的子类， 程序的行为不会有变化</strong>， 简单地说， 子类型必须能够替换掉它们的父类型。 举个例子：<strong>企鹅和鸟的关系，企鹅在生物学上属于鸟类，但在面对对象设计中 企鹅并不能以父类(鸟)的身份出现 ，因为企鹅并不具备鸟飞行的行为！</strong> 如果有两个具体的类：A,B 之间的关系违反了LSP的设计，那么根据具体的情况可以在下面的两种重构方案中选择：</p><ul><li><figure class="highlight java"><figcaption><span>创建一个新的超类C（抽象类），将A,B的共同行为转移到C中来解决问题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜() &#123;</span><br><span class="line">System.out.println(<span class="string">"红烧排骨"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜()&#123;</span><br><span class="line">System.out.println(<span class="string">"红烧鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 西点()&#123;</span><br><span class="line">System.out.println(<span class="string">"蛋糕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Son s = <span class="keyword">new</span> Son();</span><br><span class="line">s.菜();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> <span class="keyword">extends</span> <span class="title">Mom</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜() &#123;</span><br><span class="line"><span class="keyword">super</span>.家传菜(<span class="string">"红烧排骨"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Mom</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜()&#123;</span><br><span class="line"><span class="keyword">super</span>.家传菜(<span class="string">"红烧鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 西点()&#123;</span><br><span class="line">System.out.println(<span class="string">"蛋糕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mom</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 家传菜(String 菜) &#123;</span><br><span class="line">System.out.println(菜);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son s = <span class="keyword">new</span> Son();</span><br><span class="line">s.菜();</span><br><span class="line"></span><br><span class="line">Dad d = <span class="keyword">new</span> Son();</span><br><span class="line">d.菜();</span><br><span class="line">这样的话行为没有改变，行为都是做家传菜 但是做出来的家传菜内容不一样！</span><br></pre></td></tr></table></figure></li><li><p><strong>以下方式经常被实际运用</strong></p><figure class="highlight java"><figcaption><span>从B到A的继承关系改为委派关系。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">原本继承关系(Inheritance)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A Data"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.print();</span><br><span class="line"></span><br><span class="line">变成委派关系(Delegation)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"The Delegate"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.print();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;里氏代换原则-——-LSP&quot;&gt;&lt;a href=&quot;#里氏代换原则-——-LSP&quot; class=&quot;headerlink&quot; title=&quot;里氏代换原则 —— LSP&quot;&gt;&lt;/a&gt;里氏代换原则 —— LSP&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;任何基类可以出现的地方，子类一定可以出现！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;里氏替换原则，OCP作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将&lt;strong&gt;设计中的静态结构改为动态结构，维持设计的封闭性&lt;/strong&gt;。“抽象”是语言提供的功能。“多态”由继承语义实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="设计模式" scheme="https://2egg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Single responsibility principle - 单一职责原则</title>
    <link href="https://2egg.github.io/2019/04/26/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E9%99%A2%E5%AD%90/"/>
    <id>https://2egg.github.io/2019/04/26/单一职责院子/</id>
    <published>2019-04-26T09:09:50.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单一职责原则-——-SRP"><a href="#单一职责原则-——-SRP" class="headerlink" title="单一职责原则 —— SRP"></a>单一职责原则 —— SRP</h2><blockquote><p>一个类应该只有一个发生变化的原因</p><footer><strong>Robert C. Martin</strong><cite>敏捷软件开发：原则、模式和实践</cite></footer></blockquote><p>&emsp;&emsp;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。(看看就行)</p><p>&emsp;&emsp;<strong>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性</strong>。<br><a id="more"></a><br>&emsp;&emsp;内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。（T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2被耦合在了一起。）</p><p>&emsp;&emsp;<strong>程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。</strong>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><h3 id="实现单一职责原则的好处"><a href="#实现单一职责原则的好处" class="headerlink" title="实现单一职责原则的好处"></a>实现单一职责原则的好处</h3><ol><li>降低类的复杂度；</li><li>提高类的可读性，提高系统的可维护性；</li><li>降低变更引起的风险（降低对其他功能的影响）;</li></ol><h3 id="实现单一职责原则的注意点"><a href="#实现单一职责原则的注意点" class="headerlink" title="实现单一职责原则的注意点"></a>实现单一职责原则的注意点</h3><ol><li>单一职责原则最难划分的是职责。</li><li>单一职责原则提出标准：用职责和变化原因来</li></ol><h3 id="错误Demo"><a href="#错误Demo" class="headerlink" title="错误Demo"></a>错误Demo</h3><p>&emsp;&emsp;假设机器有四个步骤分别为：<strong>通电，启动，停止，断电</strong>；我们正确的方式应该是每个步骤写一个方法，最后写一个方法的集合，内容：什么时候调用通电 什么时候启动，什么时候停止，什么时候断电，而不是直接将四个步骤集合在一起，如果四个方法集合在一起的话，首先的问题是<strong>职责太多</strong>，不用解释，其次如果有一天我们只需要启动这个机器 不需要别的步骤 还需要再次寻找方法集合中的启动有哪些 复制出来之后<strong>冗余太多</strong>，最后的问题是我们自己都<strong>看不懂</strong>自己当初怎么写的了 内容太多，逻辑加控制，假设现在新增加一个需求，机器在通电之后3分钟之内没有启动的话自动执行断电，到这个时候我们就会很麻烦 首先步骤需要重新调试，其次控制也需要增加逻辑等等一系列问题…..</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单一职责原则-——-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-——-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则 —— SRP&quot;&gt;&lt;/a&gt;单一职责原则 —— SRP&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;一个类应该只有一个发生变化的原因&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Robert C. Martin&lt;/strong&gt;&lt;cite&gt;敏捷软件开发：原则、模式和实践&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。(看看就行)&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="设计模式" scheme="https://2egg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns of Java - 设计原则JAVA</title>
    <link href="https://2egg.github.io/2019/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://2egg.github.io/2019/04/23/设计模式/</id>
    <published>2019-04-23T05:13:18.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-the-design-pattern"><a href="#What-is-the-design-pattern" class="headerlink" title="What is the design pattern?"></a>What is the design pattern?</h3><blockquote><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><footer><strong>百度</strong><cite><a href="https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fr=aladdin" target="_blank" rel="noopener">设计模式概念</a></cite></footer></blockquote><a id="more"></a><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？<br>面向对象有几个原则：<br>    开闭原则（Open Closed Principle，OCP）、<br>    单一职责原则（Single Responsiblity Principle SRP）、<br>    里氏代换原则（Liskov Substitution Principle，LSP）、<br>    依赖倒转原则（Dependency Inversion Principle，DIP）、<br>    接口隔离原则（Interface Segregation Principle，ISP）、<br>    合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、<br>    最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）。<br>    开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。<br>    设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的</p><footer><strong>百度</strong><cite><a href="https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fr=aladdin" target="_blank" rel="noopener">设计模式设计原则</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-the-design-pattern&quot;&gt;&lt;a href=&quot;#What-is-the-design-pattern&quot; class=&quot;headerlink&quot; title=&quot;What is the design pattern?&quot;&gt;&lt;/a&gt;What is the design pattern?&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。&lt;br&gt;使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;百度&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式概念&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="设计模式" scheme="https://2egg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的写作标签</title>
    <link href="https://2egg.github.io/2019/04/19/Hexo%E7%9A%84%E5%86%99%E4%BD%9C%E6%A0%87%E7%AD%BE/"/>
    <id>https://2egg.github.io/2019/04/19/Hexo的写作标签/</id>
    <published>2019-04-19T08:55:08.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/19/Hexo的写作标签/Hexo.png" alt="图标"><br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>第一篇文章,查看<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a>以获取更多信息.</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight objc"><figcaption><span>常用命令</span><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">更多命令</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--启动服务--&gt;</span><br><span class="line">hexo server</span><br><span class="line">&lt;!--创建草稿--&gt;</span><br><span class="line">hexo new draft My New Post test</span><br><span class="line">&lt;!--草稿移动至_posts  --&gt;</span><br><span class="line">hexo publish draft My New Post test</span><br><span class="line">&lt;!--创建新文章--&gt;</span><br><span class="line">hexo new post <span class="string">"My New Post"</span></span><br><span class="line">&lt;!--生成静态文件--&gt;</span><br><span class="line">hexo generate</span><br><span class="line">&lt;!--清除--&gt;</span><br><span class="line">hexo clean</span><br><span class="line">&lt;!--部署--&gt;</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>参照<a href="https://www.runoob.com/markdown/md-title.html" title="markdown菜鸟" target="_blank" rel="noopener">markdown</a>语法,部分特殊语法需查看HEXO<a href="https://hexo.io/zh-cn/docs/tag-plugins" title="Hexo 文档" target="_blank" rel="noopener">文档</a></p><p>特殊：</p><ol><li>$markdown$ 自带的引用无法表名来源</li><li>代码无法显示实际效果 例如：flow类代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/04/19/Hexo的写作标签/Hexo.png&quot; alt=&quot;图标&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;第一篇文章,查看&lt;a href=
      
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Hexo" scheme="https://2egg.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>

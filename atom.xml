<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>2egg</title>
  
  <subtitle>2egg的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2egg.github.io/"/>
  <updated>2021-05-19T03:04:34.507Z</updated>
  <id>https://2egg.github.io/</id>
  
  <author>
    <name>HLJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql round函数四舍五入不正确</title>
    <link href="https://2egg.github.io/2021/05/18/Mysql_round/"/>
    <id>https://2egg.github.io/2021/05/18/Mysql_round/</id>
    <published>2021-05-18T01:01:21.000Z</published>
    <updated>2021-05-19T03:04:34.507Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现<strong>Mysql</strong>中<code>round()</code>函数 <strong>取整方式会因参数的类型会有所不同</strong>，例如参数类型为<strong>整数</strong>或<strong>Decimal</strong>时，该函数会按照四舍五入规则正确取整。但是参数类型为<strong>Double</strong>时,会与正常四舍五入后的值不同。</p><h5 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">2.5,</span><br><span class="line">25E-1,</span><br><span class="line">round(2.5),</span><br><span class="line">round(25E-1)</span><br></pre></td></tr></table></figure><p>结果为</p><table><thead><tr><th style="text-align:center">2.5</th><th style="text-align:center">25E-1</th><th style="text-align:center">round(2.5)</th><th style="text-align:center">round(25E-1)</th></tr></thead><tbody><tr><td style="text-align:center">2.5</td><td style="text-align:center">2.5</td><td style="text-align:center">3</td><td style="text-align:center">2.0</td></tr></tbody></table><p><img src="/2021/05/18/Mysql_round/mysql_round.png" alt="图标"></p><p>​    <u>E：科学计数法（<strong>aEb = a×10^b</strong>）</u></p><h5 id="mysql-文档解释"><a href="#mysql-文档解释" class="headerlink" title="mysql 文档解释"></a>mysql 文档解释</h5><p>该<code>round()</code>函数根据其参数是精确的还是近似的取整方式不同：</p><ul><li>对于精确值数字，请 <code>round()</code>使用“四舍五入”规则：如果分数为0.5或更大的分数，则将其四舍五入到下一个整数（如果为正数）或四舍五入到下一个整数（如果为负数）。（换句话说，四舍五入为零。）小数部分小于.5的值如果为正则四舍五入到下一个整数，如果为负则四舍五入到下一个整数。（换句话说，它四舍五入为零。）</li><li>对于近似值数字，结果取决于C库。在许多系统上，这意味着 <code>round()</code>使用“四舍五入到最接近的偶数”规则：<strong>小数部分位于两个整数中间的一半的值将四舍五入到最接近的偶数整数</strong>。</li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>如四舍五入之后不正确 round之前检查该参数类型如为double 就是参数类型不正确的缘故。，工作中如涉及到小数精确尽量使用decimal 具体小数精度需参照实际情况设定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现&lt;strong&gt;Mysql&lt;/strong&gt;中&lt;code&gt;round()&lt;/code&gt;函数 &lt;strong&gt;取整方式会因参数的类型会有所不同&lt;/strong&gt;，例如参数类型为&lt;strong&gt;整数&lt;/strong&gt;或&lt;strong&gt;Decimal&lt;/strong&gt;时，
      
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Mysql" scheme="https://2egg.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>更新显卡驱动出错</title>
    <link href="https://2egg.github.io/2021/05/14/%E6%9B%B4%E6%96%B0%E6%98%BE%E5%8D%A1%E5%87%BA%E9%94%99/"/>
    <id>https://2egg.github.io/2021/05/14/更新显卡出错/</id>
    <published>2021-05-14T02:57:59.000Z</published>
    <updated>2021-05-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新显卡出错，提示缺少<code>SHA-2</code>更新补丁 需要安装两个更新补丁.</p><p>下载地址：</p><ol><li><a href="https://www.catalog.update.microsoft.com/search.aspx?q=4490628" target="_blank" rel="noopener">kb4474419</a></li><li><a href="https://www.catalog.update.microsoft.com/search.aspx?q=4490628" target="_blank" rel="noopener">kb4490628</a></li></ol><p>根据系统选择下载好驱动版本之后，windows 7 系统如果直接安装，可能出现提示框 <code>安装程序遇到错误：0x80240037</code> </p><p>解决方案：</p><ol><li><p>补丁文件复制一份（避免出错再次下载）.</p></li><li><p>更改复制后的补丁文件<strong>后缀名</strong>（<strong><em>.msu</em></strong> 改为<strong><em>.cab</em></strong>）</p><p><img src="/2021/05/14/更新显卡出错/image-20210514112011301.png" alt="image-20210514112011301"></p></li><li><p>解压该文件至<strong>新文件夹</strong>中(kb4474419)</p><p><img src="/2021/05/14/更新显卡出错/image-20210514111816706.png" alt="image-20210514111816706"></p></li><li><p>点击开始菜单 搜索 <strong>cmd.exe</strong> ,右键以管理员身份运行</p></li><li><p>输入该命令后<strong>修改命令中的路径</strong>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 6.1.7601]</span><br><span class="line">版权所有 (c) 2009 Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">C:\windows\system32&gt;dism /online /add-package /packagepath:"C:\test\kb4474419\Windows6.1-KB4474419-v3-x64.cab"</span><br></pre></td></tr></table></figure></li></ol><p>6.等待安装完成，另外一个补丁同上操作</p><p>补丁安装完成之后就可以继续更新显卡了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更新显卡出错，提示缺少&lt;code&gt;SHA-2&lt;/code&gt;更新补丁 需要安装两个更新补丁.&lt;/p&gt;
&lt;p&gt;下载地址：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.catalog.update.microsoft.com/search.aspx?q=4
      
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="显卡" scheme="https://2egg.github.io/tags/%E6%98%BE%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>高并发</title>
    <link href="https://2egg.github.io/2021/05/13/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>https://2egg.github.io/2021/05/13/高并发/</id>
    <published>2021-05-13T03:21:25.000Z</published>
    <updated>2021-05-13T03:23:06.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高并发&quot;&gt;&lt;a href=&quot;#高并发&quot; class=&quot;headerlink&quot; title=&quot;高并发&quot;&gt;&lt;/a&gt;高并发&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="https://2egg.github.io/2021/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>https://2egg.github.io/2021/05/13/数据库事务/</id>
    <published>2021-05-13T02:16:02.000Z</published>
    <updated>2021-05-13T03:19:36.103Z</updated>
    
    <content type="html"><![CDATA[<h5 id="特性-ACID"><a href="#特性-ACID" class="headerlink" title="特性 - ACID"></a>特性 - ACID</h5><ol><li>atomicity(原子性) - .一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做</li><li>consistency(一致性) - 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的</li><li>isolation(隔离性) - 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li>durability(持久性) - 持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</li></ol><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a><a href="https://baike.baidu.com/item/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" target="_blank" rel="noopener">隔离级别</a></h5><blockquote><p>一个事务必须与由其他事务进行的资源或数据更改<strong>相隔离的程度</strong>。隔离级别从允许的<strong>并发副作用</strong>（例如，脏读或虚拟读取）的角度进行描述。</p></blockquote><h6 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h6><p>不同级别带来的副作用</p><table><thead><tr><th></th><th>隔离级别</th><th><a href="https://baike.baidu.com/item/%E8%84%8F%E8%AF%BB" target="_blank" rel="noopener">脏读</a></th><th><a href="https://baike.baidu.com/item/不可重复读/129509" target="_blank" rel="noopener">不可重复读</a></th><th><a href="https://baike.baidu.com/item/%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener">幻读</a></th></tr></thead><tbody><tr><td>read uncommitted</td><td>未提交读</td><td>是</td><td>是</td><td>是</td></tr><tr><td>read committed</td><td>已提交读</td><td>否</td><td>是</td><td>是</td></tr><tr><td>repeatable read</td><td><a href="https://baike.baidu.com/item/可重复读/5803956" target="_blank" rel="noopener">可重复读</a></td><td>否</td><td>否</td><td>是</td></tr><tr><td>SNAPSHOT</td><td>快照</td><td>否</td><td>否</td><td>否</td></tr><tr><td>serializable</td><td>可<a href="https://baike.baidu.com/item/序列化/2890184" target="_blank" rel="noopener">序列化</a>(串行读)</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ol><li>脏读:一事务对数据进行了增删改,但未提交,有可能<a href="https://baike.baidu.com/item/回滚" target="_blank" rel="noopener">回滚</a>,另一事务却读取了未提交的数据</li><li>不可重复读:一<a href="https://baike.baidu.com/item/事务" target="_blank" rel="noopener">事务</a>对数据进行了更新或删除操作,另一事务两次查询的数据不一致</li><li>幻读:一事务对数据进行了新增操作,另一事务两次查询的数据不一致</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;特性-ACID&quot;&gt;&lt;a href=&quot;#特性-ACID&quot; class=&quot;headerlink&quot; title=&quot;特性 - ACID&quot;&gt;&lt;/a&gt;特性 - ACID&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;atomicity(原子性) - .一个事务是一个不可分割的工作单位，事务中包括
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://2egg.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>网站搜索引擎收录</title>
    <link href="https://2egg.github.io/2019/07/30/%E7%BD%91%E7%AB%99%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95/"/>
    <id>https://2egg.github.io/2019/07/30/网站搜索引擎收录/</id>
    <published>2019-07-30T08:54:11.000Z</published>
    <updated>2020-07-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>搜索引擎快照，是指在访客在无法打开某个搜索结果，或者打开速度特别慢的情况下，为访客提供的之前保存在搜索引擎服务器上对应网页内容的纯文本。不过，搜索引擎保存的快照内容一般只包括文本数据，图片及其他多媒体等非文本数据不会被保存。因此，在来源网站无法访问的情况下，图片及其他多媒体在快照中将无法显示。</p><footer><strong>百度百科</strong><cite><a href="https://baike.baidu.com/item/快照/327038" target="_blank" rel="noopener">baike.baidu.com/item/快照/327038</a></cite></footer></blockquote><ol><li><p>百度</p><ol><li>登陆注册<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度搜索资源资源平台</a></li><li>进入用户中心-站点管理-添加网站</li><li>勾选网站属性</li><li>验证网站（下载验证文件<u><em>baidu_verify_<em>**</em>.html</em></u> 存放至域名根目录下 测试该文件是否可以访问,最后点击完成验证.）</li><li>验证之后点击该网站链接 可以看到所有网站关于搜索的情况</li><li>点击搜索展现-HTTPS认证（需要保证全站所有链接都支持HTTPS访问）</li><li>验证成功之后再次搜索就基本可以看到主页了（但是具体的文章内容什么时候可以搜到这个不太清楚）</li></ol></li><li><p>谷歌</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;搜索引擎快照，是指在访客在无法打开某个搜索结果，或者打开速度特别慢的情况下，为访客提供的之前保存在搜索引擎服务器上对应网页内容的纯文本。不过，搜索引擎保存的快照内容一般只包括文本数据，图片及其他多媒体等非文本数据不会被保存。因此，在来源网站无法访问的
      
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="https://2egg.github.io/2019/06/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://2egg.github.io/2019/06/23/负载均衡/</id>
    <published>2019-06-23T03:20:35.000Z</published>
    <updated>2019-07-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>​    多台服务器组成一台服务器集合，每台服务器都具有等价的地位， 可以单独提供服务且无需其他服务器的辅助，通过某种负载分担技术，将外部发送来的请求 均衡的分配到服务器集合中的每一台服务器上，而接受到请求的服务器独立的回应客户请求。 </p><a id="more"></a><p>​    负载均衡是高可用网络基础架构的一个关键组成部分， 有了负载均衡，我们通常可以将我们的应用服务器部署多个，然后通过负载均衡将用户的请求发送到不同的服务器来提高网站，应用，数据库或者其他服务的性能以及可靠性。</p><p>​    正常情况下多个用户通过网络 访问单个服务器，数据库处理数据，如果出现服务器宕机的情况的话，在只有一个服务器的下，用户的请求就会得不到回应（单点故障问题），又或者N个用户在段时间内访问同一服务器，超过了服务器的处理能力，会产生响应速度慢 甚至无法连接到服务器的情况。</p><h5 id="负载均衡方案"><a href="#负载均衡方案" class="headerlink" title="负载均衡方案"></a>负载均衡方案</h5><p>​    通过一个负载均衡器、至少两个web服务器、由 均衡器根据业务逻辑（比如：某个服务器通过运行状态检查服务检查此服务器已经宕机，将不分配用户请求给此服务器，直至检查服务器状态为”健康”在将用户请求发送给此服务器。）分配用户请求转发至某个服务器。</p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ip列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ipMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; serverWeightMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.100"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.101"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 权重为4</span></span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.102"</span>, <span class="number">4</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.103"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.104"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 权重为3</span></span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.105"</span>, <span class="number">3</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.106"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 权重为2</span></span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.107"</span>, <span class="number">2</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.108"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.109"</span>, <span class="number">1</span>);</span><br><span class="line">            serverWeightMap.put(<span class="string">"192.168.1.110"</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h6><p>向集合中添加负载地址 加权 添加单个负载地址个数  随机负载个数，循环转发请求到服务器上，次数足够多的的情况下，每个负载地址根据权重所接受的请求次数 与集合长度是成比例的。</p><ul><li>优点：使用简单</li><li>缺点：不适合机器配置不同的场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 重建一个Map，避免服务器的上下线导致的并发问题</span></span><br><span class="line">       Map&lt;String, Integer&gt; serverMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">       serverMap.putAll(ipMap.serverWeightMap);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 取得Ip地址List</span></span><br><span class="line">       Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">       Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; serverList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           String server = iterator.next();</span><br><span class="line">           <span class="keyword">int</span> weight = serverMap.get(server);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++)</span><br><span class="line">               serverList.add(server);</span><br><span class="line">       &#125;</span><br><span class="line">       java.util.Random random = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">       <span class="keyword">int</span> randomPos = random.nextInt(serverList.size());</span><br><span class="line">       <span class="keyword">return</span> serverList.get(randomPos);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h6><p>为第一个请求选择健康池中的第一个后端服务器，然后按顺序往后依次选择，直到最后一个，然后循环。</p><ul><li>优点：服务器请求数目相同</li><li>缺点：服务器压力不一致，不合适服务器配置不同的情况；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pollingIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重建一个Map，避免服务器的上下线导致的并发问题</span></span><br><span class="line">        Map&lt;String, Integer&gt; serverMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        serverMap.putAll(ipMap.serverWeightMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得Ip地址List</span></span><br><span class="line">        Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; serverList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String server = iterator.next();</span><br><span class="line">            <span class="keyword">int</span> weight = serverMap.get(server);</span><br><span class="line">            <span class="comment">/*循环获取map 中的key 的value 是多少 放入list中 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++)</span><br><span class="line">                serverList.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">        String server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (pos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt; keySet.size())</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            server = serverList.get(pos);</span><br><span class="line">            pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="最小连接"><a href="#最小连接" class="headerlink" title="最小连接"></a>最小连接</h6><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有 快有慢，它正是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能地提高后端服务器的利用效率，将负载 合理地分流到每一台机器。由于最小连接数设计服务器连接数的汇总和感知，设计与实现较为繁琐。</p><ul><li>优点：根据服务器当前的情况处理请求，动态分配</li><li>缺点：算法实现相对复杂，需要监控服务器请求连接数；</li></ul><h6 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h6><p>根据请求源的某一值(IP)的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器，可以考虑采取这种方式。</p><ul><li>优点：将来自同一ip地址的请求，同一会话期内，转发到相同的服务器，直到后端服务器列表变更， 根据此特性 可以在服务先飞这与服务提供者之间建立有状态的session会话 实现会话粘贴。</li><li>缺点：某一目标服务器宕机后，当前服务器会话消失，出现hash倾斜</li></ul><p>出现hash倾斜的解决方案：虚拟节点，在真实的服务器节点之间 添加 添加服务器节点映射(虚拟节点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hash</span><span class="params">(String remoteIp)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 重建一个Map，避免服务器的上下线导致的并发问题</span></span><br><span class="line">       Map&lt;String, Integer&gt; serverMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">       serverMap.putAll(ipMap.serverWeightMap);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 取得Ip地址List</span></span><br><span class="line">       Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">       ArrayList&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       keyList.addAll(keySet);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 在Web应用中可通过HttpServlet的getRemoteIp方法获取</span></span><br><span class="line">       <span class="comment">//String remoteIp = "127.0.0.1";</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> hashCode = remoteIp.hashCode();</span><br><span class="line">       <span class="keyword">int</span> serverListSize = keyList.size();</span><br><span class="line">       <span class="keyword">int</span> serverPos = hashCode % serverListSize;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> keyList.get(serverPos);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h5><p>实际项目中的话肯定是多个均衡算法糅合在一起实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h5&gt;&lt;p&gt;​    多台服务器组成一台服务器集合，每台服务器都具有等价的地位， 可以单独提供服务且无需其他服务器的辅助，通过某种负载分担技术，将外部发送来的请求 均衡的分配到服务器集合中的每一台服务器上，而接受到请求的服务器独立的回应客户请求。 &lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Liskov Substitution Principle - 里氏代换原则</title>
    <link href="https://2egg.github.io/2019/05/05/%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>https://2egg.github.io/2019/05/05/里氏代换原则/</id>
    <published>2019-05-05T06:54:37.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="里氏代换原则-——-LSP"><a href="#里氏代换原则-——-LSP" class="headerlink" title="里氏代换原则 —— LSP"></a>里氏代换原则 —— LSP</h2><blockquote><p>任何基类可以出现的地方，子类一定可以出现！</p></blockquote><p>&emsp;&emsp;里氏替换原则，OCP作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将<strong>设计中的静态结构改为动态结构，维持设计的封闭性</strong>。“抽象”是语言提供的功能。“多态”由继承语义实现。<br><a id="more"></a><br>里氏替换原则包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li><li>子类可以增加自己特有的方法。</li><li>当子类覆盖或者实现父类的方法时，方法的前置条件（方法的形象）要比父类的方法输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值） 要比父类的更加严谨。</li></ul><p>&emsp;&emsp;LSP 一个软件如果使用的是一个父类的话， 那么一定适用于其子类， 而察觉不出父类对象和子类对象的区别。 也即是说，在软件里面，<strong> 把父类替换成它的子类， 程序的行为不会有变化</strong>， 简单地说， 子类型必须能够替换掉它们的父类型。 举个例子：<strong>企鹅和鸟的关系，企鹅在生物学上属于鸟类，但在面对对象设计中 企鹅并不能以父类(鸟)的身份出现 ，因为企鹅并不具备鸟飞行的行为！</strong> 如果有两个具体的类：A,B 之间的关系违反了LSP的设计，那么根据具体的情况可以在下面的两种重构方案中选择：</p><ul><li><figure class="highlight java"><figcaption><span>创建一个新的超类C（抽象类），将A,B的共同行为转移到C中来解决问题。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜() &#123;</span><br><span class="line">System.out.println(<span class="string">"红烧排骨"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜()&#123;</span><br><span class="line">System.out.println(<span class="string">"红烧鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 西点()&#123;</span><br><span class="line">System.out.println(<span class="string">"蛋糕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Son s = <span class="keyword">new</span> Son();</span><br><span class="line">s.菜();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> <span class="keyword">extends</span> <span class="title">Mom</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜() &#123;</span><br><span class="line"><span class="keyword">super</span>.家传菜(<span class="string">"红烧排骨"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Mom</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 菜()&#123;</span><br><span class="line"><span class="keyword">super</span>.家传菜(<span class="string">"红烧鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 西点()&#123;</span><br><span class="line">System.out.println(<span class="string">"蛋糕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mom</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> 家传菜(String 菜) &#123;</span><br><span class="line">System.out.println(菜);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son s = <span class="keyword">new</span> Son();</span><br><span class="line">s.菜();</span><br><span class="line"></span><br><span class="line">Dad d = <span class="keyword">new</span> Son();</span><br><span class="line">d.菜();</span><br><span class="line">这样的话行为没有改变，行为都是做家传菜 但是做出来的家传菜内容不一样！</span><br></pre></td></tr></table></figure></li><li><p><strong>以下方式经常被实际运用</strong></p><figure class="highlight java"><figcaption><span>从B到A的继承关系改为委派关系。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">原本继承关系(Inheritance)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A Data"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.print();</span><br><span class="line"></span><br><span class="line">变成委派关系(Delegation)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"The Delegate"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.print();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;里氏代换原则-——-LSP&quot;&gt;&lt;a href=&quot;#里氏代换原则-——-LSP&quot; class=&quot;headerlink&quot; title=&quot;里氏代换原则 —— LSP&quot;&gt;&lt;/a&gt;里氏代换原则 —— LSP&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;任何基类可以出现的地方，子类一定可以出现！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;里氏替换原则，OCP作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将&lt;strong&gt;设计中的静态结构改为动态结构，维持设计的封闭性&lt;/strong&gt;。“抽象”是语言提供的功能。“多态”由继承语义实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="设计模式" scheme="https://2egg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Single responsibility principle - 单一职责原则</title>
    <link href="https://2egg.github.io/2019/04/26/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E9%99%A2%E5%AD%90/"/>
    <id>https://2egg.github.io/2019/04/26/单一职责院子/</id>
    <published>2019-04-26T09:09:50.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单一职责原则-——-SRP"><a href="#单一职责原则-——-SRP" class="headerlink" title="单一职责原则 —— SRP"></a>单一职责原则 —— SRP</h2><blockquote><p>一个类应该只有一个发生变化的原因</p><footer><strong>Robert C. Martin</strong><cite>敏捷软件开发：原则、模式和实践</cite></footer></blockquote><p>&emsp;&emsp;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。(看看就行)</p><p>&emsp;&emsp;<strong>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性</strong>。<br><a id="more"></a><br>&emsp;&emsp;内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。（T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2被耦合在了一起。）</p><p>&emsp;&emsp;<strong>程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。</strong>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><h3 id="实现单一职责原则的好处"><a href="#实现单一职责原则的好处" class="headerlink" title="实现单一职责原则的好处"></a>实现单一职责原则的好处</h3><ol><li>降低类的复杂度；</li><li>提高类的可读性，提高系统的可维护性；</li><li>降低变更引起的风险（降低对其他功能的影响）;</li></ol><h3 id="实现单一职责原则的注意点"><a href="#实现单一职责原则的注意点" class="headerlink" title="实现单一职责原则的注意点"></a>实现单一职责原则的注意点</h3><ol><li>单一职责原则最难划分的是职责。</li><li>单一职责原则提出标准：用职责和变化原因来</li></ol><h3 id="错误Demo"><a href="#错误Demo" class="headerlink" title="错误Demo"></a>错误Demo</h3><p>&emsp;&emsp;假设机器有四个步骤分别为：<strong>通电，启动，停止，断电</strong>；我们正确的方式应该是每个步骤写一个方法，最后写一个方法的集合，内容：什么时候调用通电 什么时候启动，什么时候停止，什么时候断电，而不是直接将四个步骤集合在一起，如果四个方法集合在一起的话，首先的问题是<strong>职责太多</strong>，不用解释，其次如果有一天我们只需要启动这个机器 不需要别的步骤 还需要再次寻找方法集合中的启动有哪些 复制出来之后<strong>冗余太多</strong>，最后的问题是我们自己都<strong>看不懂</strong>自己当初怎么写的了 内容太多，逻辑加控制，假设现在新增加一个需求，机器在通电之后3分钟之内没有启动的话自动执行断电，到这个时候我们就会很麻烦 首先步骤需要重新调试，其次控制也需要增加逻辑等等一系列问题…..</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单一职责原则-——-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-——-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则 —— SRP&quot;&gt;&lt;/a&gt;单一职责原则 —— SRP&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;一个类应该只有一个发生变化的原因&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Robert C. Martin&lt;/strong&gt;&lt;cite&gt;敏捷软件开发：原则、模式和实践&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。(看看就行)&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="设计模式" scheme="https://2egg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Open Close Principle - 开闭原则</title>
    <link href="https://2egg.github.io/2019/04/24/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>https://2egg.github.io/2019/04/24/开闭原则/</id>
    <published>2019-04-24T01:11:30.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开闭原则-——-OCP"><a href="#开闭原则-——-OCP" class="headerlink" title="开闭原则 —— OCP"></a>开闭原则 —— OCP</h3><blockquote><p>Software entities should be open for extension,but closed for modification(模块应对扩展开放,而对修改关闭！)</p><footer><strong>Bertrand Meyer</strong><cite>Wide Awake</cite></footer></blockquote><p>模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂(Factory) 有一条生产线(prodLine),生产"产品A".</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">prodLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产品A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户 订购该工厂的该产品(产品A)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我订购并收到产品："</span>+order());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        <span class="keyword">return</span> factory.prodLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行效果</span></span><br><span class="line">我订购并收到产品：产品A</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现因为市场需求改变增加,需要新加一条生产"产品B"的生产线, 但是资金有限。</span></span><br><span class="line"><span class="comment">  只能再原有的生产线上增加功能(既可以生产A，又可以生产B)*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">prodLine</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"产品A"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"产品B"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当我们修改之后 会发现客户方有问题（订购不了产品） 因为什么！ </span></span><br><span class="line"><span class="comment">因为我们需要知道客户到底要什么产品(type)，客户没说，我们也不能做啊，不然做出来退货怎么办(出BUG)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我订购并收到产品："</span>+order());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line"><span class="comment">//客户申明要什么产品</span></span><br><span class="line">        <span class="keyword">return</span> factory.prodLine(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">我订购并收到产品：产品A</span><br></pre></td></tr></table></figure></p><p>以上只是最基本的<br><figure class="highlight java"><figcaption><span>开闭原则</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//我们建厂之前需要提前写一个设计稿(接口)为未来做准备 比如 生产N种产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">prodLine</span><span class="params">(<span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在市场上 出现了需要产品的客户 我们直接按照接口 建造工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">prodLine</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"产品A"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"产品B"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户方  没有变化 申明产品的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我订购并收到产品："</span>+order());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line"><span class="comment">//客户申明要什么产品</span></span><br><span class="line">        <span class="keyword">return</span> factory.prodLine(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我订购并收到产品：产品A/B</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开闭原则-——-OCP&quot;&gt;&lt;a href=&quot;#开闭原则-——-OCP&quot; class=&quot;headerlink&quot; title=&quot;开闭原则 —— OCP&quot;&gt;&lt;/a&gt;开闭原则 —— OCP&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Software entities should be open for extension,but closed for modification(模块应对扩展开放,而对修改关闭！)&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Bertrand Meyer&lt;/strong&gt;&lt;cite&gt;Wide Awake&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="设计模式" scheme="https://2egg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns of Java - 设计原则JAVA</title>
    <link href="https://2egg.github.io/2019/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://2egg.github.io/2019/04/23/设计模式/</id>
    <published>2019-04-23T05:13:18.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-the-design-pattern"><a href="#What-is-the-design-pattern" class="headerlink" title="What is the design pattern?"></a>What is the design pattern?</h3><blockquote><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><footer><strong>百度</strong><cite><a href="https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fr=aladdin" target="_blank" rel="noopener">设计模式概念</a></cite></footer></blockquote><a id="more"></a><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？<br>面向对象有几个原则：<br>    开闭原则（Open Closed Principle，OCP）、<br>    单一职责原则（Single Responsiblity Principle SRP）、<br>    里氏代换原则（Liskov Substitution Principle，LSP）、<br>    依赖倒转原则（Dependency Inversion Principle，DIP）、<br>    接口隔离原则（Interface Segregation Principle，ISP）、<br>    合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、<br>    最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）。<br>    开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。<br>    设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的</p><footer><strong>百度</strong><cite><a href="https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fr=aladdin" target="_blank" rel="noopener">设计模式设计原则</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-the-design-pattern&quot;&gt;&lt;a href=&quot;#What-is-the-design-pattern&quot; class=&quot;headerlink&quot; title=&quot;What is the design pattern?&quot;&gt;&lt;/a&gt;What is the design pattern?&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。&lt;br&gt;使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;百度&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式概念&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码" scheme="https://2egg.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="设计模式" scheme="https://2egg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://2egg.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的写作标签</title>
    <link href="https://2egg.github.io/2019/04/19/Hexo%E7%9A%84%E5%86%99%E4%BD%9C%E6%A0%87%E7%AD%BE/"/>
    <id>https://2egg.github.io/2019/04/19/Hexo的写作标签/</id>
    <published>2019-04-19T08:55:08.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/19/Hexo的写作标签/Hexo.png" alt="图标"><br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>第一篇文章,查看<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a>以获取更多信息.</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight objc"><figcaption><span>常用命令</span><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">更多命令</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--启动服务--&gt;</span><br><span class="line">hexo server</span><br><span class="line">&lt;!--创建草稿--&gt;</span><br><span class="line">hexo new draft My New Post test</span><br><span class="line">&lt;!--草稿移动至_posts  --&gt;</span><br><span class="line">hexo publish draft My New Post test</span><br><span class="line">&lt;!--创建新文章--&gt;</span><br><span class="line">hexo new post <span class="string">"My New Post"</span></span><br><span class="line">&lt;!--生成静态文件--&gt;</span><br><span class="line">hexo generate</span><br><span class="line">&lt;!--清除--&gt;</span><br><span class="line">hexo clean</span><br><span class="line">&lt;!--部署--&gt;</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>参照<a href="https://www.runoob.com/markdown/md-title.html" title="markdown菜鸟" target="_blank" rel="noopener">markdown</a>语法,部分特殊语法需查看HEXO<a href="https://hexo.io/zh-cn/docs/tag-plugins" title="Hexo 文档" target="_blank" rel="noopener">文档</a></p><p>特殊：</p><ol><li>$markdown$ 自带的引用无法表名来源</li><li>代码无法显示实际效果 例如：flow类代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/04/19/Hexo的写作标签/Hexo.png&quot; alt=&quot;图标&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;第一篇文章,查看&lt;a href=
      
    
    </summary>
    
      <category term="学习" scheme="https://2egg.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Hexo" scheme="https://2egg.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>

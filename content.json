{"meta":{"title":"2egg","subtitle":"2egg的博客","description":"韩良杰他很懒，而且不喜欢说话！","author":"2egg","url":"https://2egg.github.io","root":"/"},"pages":[{"title":"","date":"2021-05-07T03:08:56.155Z","updated":"2019-07-31T04:57:37.057Z","comments":true,"path":"baidu_verify_R3p8DI8eOT.html","permalink":"https://2egg.github.io/baidu_verify_R3p8DI8eOT.html","excerpt":"","text":"R3p8DI8eOT"},{"title":"相册","date":"2019-04-22T04:36:03.000Z","updated":"2019-07-30T08:18:25.277Z","comments":true,"path":"gallery/index.html","permalink":"https://2egg.github.io/gallery/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-22T04:44:02.000Z","updated":"2021-05-08T03:13:56.246Z","comments":true,"path":"about/index.html","permalink":"https://2egg.github.io/about/index.html","excerpt":"","text":"技术支持HEXO 网站支持GitHub"}],"posts":[{"title":"百度快照提交","slug":"2019-07-30 165411","date":"2019-07-30T08:54:11.000Z","updated":"2021-05-08T02:06:53.061Z","comments":true,"path":"2019/07/30/2019-07-30 165411/","link":"","permalink":"https://2egg.github.io/2019/07/30/2019-07-30 165411/","excerpt":"","text":"","categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[]},{"title":"负载均衡","slug":"2019-06-23 112035","date":"2019-06-23T03:20:35.000Z","updated":"2021-05-10T07:59:30.315Z","comments":true,"path":"2019/06/23/2019-06-23 112035/","link":"","permalink":"https://2egg.github.io/2019/06/23/2019-06-23 112035/","excerpt":"负载均衡​ 多台服务器组成一台服务器集合，每台服务器都具有等价的地位， 可以单独提供服务且无需其他服务器的辅助，通过某种负载分担技术，将外部发送来的请求 均衡的分配到服务器集合中的每一台服务器上，而接受到请求的服务器独立的回应客户请求。","text":"负载均衡​ 多台服务器组成一台服务器集合，每台服务器都具有等价的地位， 可以单独提供服务且无需其他服务器的辅助，通过某种负载分担技术，将外部发送来的请求 均衡的分配到服务器集合中的每一台服务器上，而接受到请求的服务器独立的回应客户请求。 ​ 负载均衡是高可用网络基础架构的一个关键组成部分， 有了负载均衡，我们通常可以将我们的应用服务器部署多个，然后通过负载均衡将用户的请求发送到不同的服务器来提高网站，应用，数据库或者其他服务的性能以及可靠性。 ​ 正常情况下多个用户通过网络 访问单个服务器，数据库处理数据，如果出现服务器宕机的情况的话，在只有一个服务器的下，用户的请求就会得不到回应（单点故障问题），又或者N个用户在段时间内访问同一服务器，超过了服务器的处理能力，会产生响应速度慢 甚至无法连接到服务器的情况。 负载均衡方案​ 通过一个负载均衡器、至少两个web服务器、由 均衡器根据业务逻辑（比如：某个服务器通过运行状态检查服务检查此服务器已经宕机，将不分配用户请求给此服务器，直至检查服务器状态为”健康”在将用户请求发送给此服务器。）分配用户请求转发至某个服务器。 算法1234567891011121314151617181920// ip列表public class ipMap &#123; public static HashMap&lt;String, Integer&gt; serverWeightMap = new HashMap&lt;String, Integer&gt;(); static &#123; serverWeightMap.put(\"192.168.1.100\", 1); serverWeightMap.put(\"192.168.1.101\", 1); // 权重为4 serverWeightMap.put(\"192.168.1.102\", 4); serverWeightMap.put(\"192.168.1.103\", 1); serverWeightMap.put(\"192.168.1.104\", 1); // 权重为3 serverWeightMap.put(\"192.168.1.105\", 3); serverWeightMap.put(\"192.168.1.106\", 1); // 权重为2 serverWeightMap.put(\"192.168.1.107\", 2); serverWeightMap.put(\"192.168.1.108\", 1); serverWeightMap.put(\"192.168.1.109\", 1); serverWeightMap.put(\"192.168.1.110\", 1); &#125;&#125; 随机向集合中添加负载地址 加权 添加单个负载地址个数 随机负载个数，循环转发请求到服务器上，次数足够多的的情况下，每个负载地址根据权重所接受的请求次数 与集合长度是成比例的。 优点：使用简单 缺点：不适合机器配置不同的场景 1234567891011121314151617181920public static String random() &#123; // 重建一个Map，避免服务器的上下线导致的并发问题 Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;(); serverMap.putAll(ipMap.serverWeightMap); // 取得Ip地址List Set&lt;String&gt; keySet = serverMap.keySet(); Iterator&lt;String&gt; iterator = keySet.iterator(); List&lt;String&gt; serverList = new ArrayList&lt;String&gt;(); while (iterator.hasNext()) &#123; String server = iterator.next(); int weight = serverMap.get(server); for (int i = 0; i &lt; weight; i++) serverList.add(server); &#125; java.util.Random random = new java.util.Random(); int randomPos = random.nextInt(serverList.size()); return serverList.get(randomPos); &#125; 轮询为第一个请求选择健康池中的第一个后端服务器，然后按顺序往后依次选择，直到最后一个，然后循环。 优点：服务器请求数目相同 缺点：服务器压力不一致，不合适服务器配置不同的情况； 1234567891011121314151617181920212223242526public static String pollingIp() &#123; // 重建一个Map，避免服务器的上下线导致的并发问题 Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;(); serverMap.putAll(ipMap.serverWeightMap); // 取得Ip地址List Set&lt;String&gt; keySet = serverMap.keySet(); Iterator&lt;String&gt; iterator = keySet.iterator(); List&lt;String&gt; serverList = new ArrayList&lt;String&gt;(); while (iterator.hasNext()) &#123; String server = iterator.next(); int weight = serverMap.get(server); /*循环获取map 中的key 的value 是多少 放入list中 */ for (int i = 0; i &lt; weight; i++) serverList.add(server); &#125; String server = null; synchronized (pos) &#123; if (pos &gt; keySet.size()) pos = 0; server = serverList.get(pos); pos ++; &#125; return server; &#125; 最小连接最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有 快有慢，它正是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能地提高后端服务器的利用效率，将负载 合理地分流到每一台机器。由于最小连接数设计服务器连接数的汇总和感知，设计与实现较为繁琐。 优点：根据服务器当前的情况处理请求，动态分配 缺点：算法实现相对复杂，需要监控服务器请求连接数； 散列根据请求源的某一值(IP)的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器，可以考虑采取这种方式。 优点：将来自同一ip地址的请求，同一会话期内，转发到相同的服务器，直到后端服务器列表变更， 根据此特性 可以在服务先飞这与服务提供者之间建立有状态的session会话 实现会话粘贴。 缺点：某一目标服务器宕机后，当前服务器会话消失，出现hash倾斜 出现hash倾斜的解决方案：虚拟节点，在真实的服务器节点之间 添加 添加服务器节点映射(虚拟节点)。 12345678910111213141516171819public static String hash(String remoteIp)&#123; // 重建一个Map，避免服务器的上下线导致的并发问题 Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;(); serverMap.putAll(ipMap.serverWeightMap); // 取得Ip地址List Set&lt;String&gt; keySet = serverMap.keySet(); ArrayList&lt;String&gt; keyList = new ArrayList&lt;String&gt;(); keyList.addAll(keySet); // 在Web应用中可通过HttpServlet的getRemoteIp方法获取 //String remoteIp = \"127.0.0.1\"; int hashCode = remoteIp.hashCode(); int serverListSize = keyList.size(); int serverPos = hashCode % serverListSize; return keyList.get(serverPos); &#125; 实际运用实际项目中的话肯定是多个均衡算法糅合在一起实现。","categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://2egg.github.io/tags/代码/"},{"name":"Java","slug":"Java","permalink":"https://2egg.github.io/tags/Java/"}]},{"title":"Liskov Substitution Principle - 里氏代换原则","slug":"2019-05-05 145437","date":"2019-05-05T06:54:37.000Z","updated":"2021-05-10T07:59:21.316Z","comments":true,"path":"2019/05/05/2019-05-05 145437/","link":"","permalink":"https://2egg.github.io/2019/05/05/2019-05-05 145437/","excerpt":"里氏代换原则 —— LSP任何基类可以出现的地方，子类一定可以出现！ &emsp;&emsp;里氏替换原则，OCP作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性。“抽象”是语言提供的功能。“多态”由继承语义实现。","text":"里氏代换原则 —— LSP任何基类可以出现的地方，子类一定可以出现！ &emsp;&emsp;里氏替换原则，OCP作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性。“抽象”是语言提供的功能。“多态”由继承语义实现。里氏替换原则包含以下4层含义： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类可以增加自己特有的方法。 当子类覆盖或者实现父类的方法时，方法的前置条件（方法的形象）要比父类的方法输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值） 要比父类的更加严谨。 &emsp;&emsp;LSP 一个软件如果使用的是一个父类的话， 那么一定适用于其子类， 而察觉不出父类对象和子类对象的区别。 也即是说，在软件里面， 把父类替换成它的子类， 程序的行为不会有变化， 简单地说， 子类型必须能够替换掉它们的父类型。 举个例子：企鹅和鸟的关系，企鹅在生物学上属于鸟类，但在面对对象设计中 企鹅并不能以父类(鸟)的身份出现 ，因为企鹅并不具备鸟飞行的行为！ 如果有两个具体的类：A,B 之间的关系违反了LSP的设计，那么根据具体的情况可以在下面的两种重构方案中选择： 创建一个新的超类C（抽象类），将A,B的共同行为转移到C中来解决问题。1234567891011121314151617181920212223242526272829303132333435363738394041class Dad &#123; void 菜() &#123; System.out.println(\"红烧排骨\"); &#125;&#125;class Son extends Dad &#123; void 菜()&#123; System.out.println(\"红烧鱼\"); &#125; void 西点()&#123; System.out.println(\"蛋糕\"); &#125;&#125;Son s = new Son();s.菜();class Dad extends Mom &#123; void 菜() &#123; super.家传菜(\"红烧排骨\"); &#125;&#125;class Son extends Mom &#123; void 菜()&#123; super.家传菜(\"红烧鱼\"); &#125; void 西点()&#123; System.out.println(\"蛋糕\"); &#125;&#125;class Mom &#123; void 家传菜(String 菜) &#123; System.out.println(菜); &#125;&#125;Son s = new Son();s.菜();Dad d = new Son();d.菜();这样的话行为没有改变，行为都是做家传菜 但是做出来的家传菜内容不一样！ 以下方式经常被实际运用 从B到A的继承关系改为委派关系。1234567891011121314151617181920212223242526272829原本继承关系(Inheritance)class A &#123; void print() &#123; System.out.println(\"A Data\"); &#125;&#125;class B extends A &#123; void print()&#123; super.print(); &#125;&#125;B b = new B();b.print();变成委派关系(Delegation)class A &#123; void print() &#123; System.out.println(\"The Delegate\"); &#125;&#125;class B &#123; A a = new A(); void print() &#123; a.print(); &#125;&#125;B b = new B();b.print();","categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://2egg.github.io/tags/代码/"},{"name":"设计模式","slug":"设计模式","permalink":"https://2egg.github.io/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"https://2egg.github.io/tags/Java/"}]},{"title":"Single responsibility principle - 单一职责原则","slug":"2019-04-26 170950","date":"2019-04-26T09:09:50.000Z","updated":"2021-05-10T07:59:16.929Z","comments":true,"path":"2019/04/26/2019-04-26 170950/","link":"","permalink":"https://2egg.github.io/2019/04/26/2019-04-26 170950/","excerpt":"单一职责原则 —— SRP一个类应该只有一个发生变化的原因 Robert C. Martin敏捷软件开发：原则、模式和实践 &emsp;&emsp;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。(看看就行) &emsp;&emsp;如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。","text":"单一职责原则 —— SRP一个类应该只有一个发生变化的原因 Robert C. Martin敏捷软件开发：原则、模式和实践 &emsp;&emsp;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。(看看就行) &emsp;&emsp;如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。&emsp;&emsp;内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。（T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2被耦合在了一起。） &emsp;&emsp;程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 实现单一职责原则的好处 降低类的复杂度； 提高类的可读性，提高系统的可维护性； 降低变更引起的风险（降低对其他功能的影响）; 实现单一职责原则的注意点 单一职责原则最难划分的是职责。 单一职责原则提出标准：用职责和变化原因来 错误Demo&emsp;&emsp;假设机器有四个步骤分别为：通电，启动，停止，断电；我们正确的方式应该是每个步骤写一个方法，最后写一个方法的集合，内容：什么时候调用通电 什么时候启动，什么时候停止，什么时候断电，而不是直接将四个步骤集合在一起，如果四个方法集合在一起的话，首先的问题是职责太多，不用解释，其次如果有一天我们只需要启动这个机器 不需要别的步骤 还需要再次寻找方法集合中的启动有哪些 复制出来之后冗余太多，最后的问题是我们自己都看不懂自己当初怎么写的了 内容太多，逻辑加控制，假设现在新增加一个需求，机器在通电之后3分钟之内没有启动的话自动执行断电，到这个时候我们就会很麻烦 首先步骤需要重新调试，其次控制也需要增加逻辑等等一系列问题…..","categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://2egg.github.io/tags/代码/"},{"name":"设计模式","slug":"设计模式","permalink":"https://2egg.github.io/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"https://2egg.github.io/tags/Java/"}]},{"title":"Open Close Principle - 开闭原则","slug":"2019-04-24 091130","date":"2019-04-24T01:11:30.000Z","updated":"2021-05-10T07:59:10.394Z","comments":true,"path":"2019/04/24/2019-04-24 091130/","link":"","permalink":"https://2egg.github.io/2019/04/24/2019-04-24 091130/","excerpt":"开闭原则 —— OCPSoftware entities should be open for extension,but closed for modification(模块应对扩展开放,而对修改关闭！) Bertrand MeyerWide Awake 模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。","text":"开闭原则 —— OCPSoftware entities should be open for extension,but closed for modification(模块应对扩展开放,而对修改关闭！) Bertrand MeyerWide Awake 模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//工厂(Factory) 有一条生产线(prodLine),生产\"产品A\".public class Factory &#123; public String prodLine()&#123; return \"产品A\"; &#125;&#125;//客户 订购该工厂的该产品(产品A)public class Client1 &#123; public static void main(String args[]) &#123; System.out.println(\"我订购并收到产品：\"+order()); &#125; private static String order()&#123; Factory factory = new Factory(); return factory.prodLine(); &#125;&#125;//执行效果我订购并收到产品：产品A/*现因为市场需求改变增加,需要新加一条生产\"产品B\"的生产线, 但是资金有限。 只能再原有的生产线上增加功能(既可以生产A，又可以生产B)*/public class Factory &#123; public String prodLine(int type) &#123; if(type == 0)&#123; return \"产品A\"; &#125;else&#123; return \"产品B\"; &#125; &#125;&#125;/*当我们修改之后 会发现客户方有问题（订购不了产品） 因为什么！ 因为我们需要知道客户到底要什么产品(type)，客户没说，我们也不能做啊，不然做出来退货怎么办(出BUG)*/public class Client1 &#123; public static void main(String args[]) &#123; System.out.println(\"我订购并收到产品：\"+order()); &#125; private static String order()&#123; Factory factory = new Factory(); //客户申明要什么产品 return factory.prodLine(0); &#125;&#125;我订购并收到产品：产品A 以上只是最基本的开闭原则1234567891011121314151617181920212223242526272829303132//我们建厂之前需要提前写一个设计稿(接口)为未来做准备 比如 生产N种产品public interface IFactory &#123; String prodLine(int type);&#125;//现在市场上 出现了需要产品的客户 我们直接按照接口 建造工厂public class FactoryA implements IFactory&#123; @Override public String prodLine(int type) &#123; if(type == 0)&#123; return \"产品A\"; &#125;else&#123; return \"产品B\"; &#125; &#125;&#125;//客户方 没有变化 申明产品的类型public class Client1 &#123; public static void main(String args[]) &#123; System.out.println(\"我订购并收到产品：\"+order()); &#125; private static String order()&#123; Factory factory = new Factory(); //客户申明要什么产品 return factory.prodLine(0); &#125;&#125;我订购并收到产品：产品A/B","categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://2egg.github.io/tags/代码/"},{"name":"设计模式","slug":"设计模式","permalink":"https://2egg.github.io/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"https://2egg.github.io/tags/Java/"}]},{"title":"Design Patterns of Java - 设计模式JAVA","slug":"2019-04-23 131318","date":"2019-04-23T05:13:18.000Z","updated":"2021-05-10T07:59:07.658Z","comments":true,"path":"2019/04/23/2019-04-23 131318/","link":"","permalink":"https://2egg.github.io/2019/04/23/2019-04-23 131318/","excerpt":"What is the design pattern?设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 百度设计模式概念","text":"What is the design pattern?设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 百度设计模式概念 设计原则为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？面向对象有几个原则： 开闭原则（Open Closed Principle，OCP）、 单一职责原则（Single Responsiblity Principle SRP）、 里氏代换原则（Liskov Substitution Principle，LSP）、 依赖倒转原则（Dependency Inversion Principle，DIP）、 接口隔离原则（Interface Segregation Principle，ISP）、 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、 最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）。 开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。 设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的 百度设计模式设计原则","categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://2egg.github.io/tags/代码/"},{"name":"设计模式","slug":"设计模式","permalink":"https://2egg.github.io/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"https://2egg.github.io/tags/Java/"}]},{"title":"Hexo的写作标签","slug":"2019-04-19 165508","date":"2019-04-19T08:55:08.000Z","updated":"2021-05-10T07:58:52.297Z","comments":true,"path":"2019/04/19/2019-04-19 165508/","link":"","permalink":"https://2egg.github.io/2019/04/19/2019-04-19 165508/","excerpt":"","text":"Hexo第一篇文章,查看文档以获取更多信息. 命令常用命令更多命令12345678//1.启动服务hexo server//2.创建新文章hexo new \"My New Post\"//3.生成静态文件hexo generate//4.部署hexo deploy 标签参照markdown语法,部分特殊语法需查看HEXO文档","categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://2egg.github.io/tags/Hexo/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://2egg.github.io/categories/学习/"}],"tags":[{"name":"代码","slug":"代码","permalink":"https://2egg.github.io/tags/代码/"},{"name":"Java","slug":"Java","permalink":"https://2egg.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://2egg.github.io/tags/设计模式/"},{"name":"Hexo","slug":"Hexo","permalink":"https://2egg.github.io/tags/Hexo/"}]}
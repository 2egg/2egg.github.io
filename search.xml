<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Single responsibility principle]]></title>
    <url>%2F2019%2F04%2F26%2FSingle-responsibility-principle%2F</url>
    <content type="text"><![CDATA[单一职责原则 —— SRP一个类应该只有一个发生变化的原因 Robert C. Martin敏捷软件开发：原则、模式和实践 &emsp;&emsp;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。(看看就行) &emsp;&emsp;如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。&emsp;&emsp;内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。（T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2被耦合在了一起。） &emsp;&emsp;程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 实现单一职责原则的好处 降低类的复杂度； 提高类的可读性，提高系统的可维护性； 降低变更引起的风险（降低对其他功能的影响）实现单一职责原则的注意点 单一职责原则最难划分的是职责。 单一职责原则提出标准：用职责和变化原因来]]></content>
  </entry>
  <entry>
    <title><![CDATA[Open Close Principle]]></title>
    <url>%2F2019%2F04%2F24%2FOpen-Close-Principle%2F</url>
    <content type="text"><![CDATA[开闭原则 —— OCPSoftware entities should be open for extension,but closed for modification(模块应对扩展开放,而对修改关闭！) Bertrand MeyerWide Awake 模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//工厂(Factory) 有一条生产线(prodLine),生产"产品A".public class Factory &#123; public String prodLine()&#123; return "产品A"; &#125;&#125;//客户 订购该工厂的该产品(产品A)public class Client1 &#123; public static void main(String args[]) &#123; System.out.println("我订购并收到产品："+order()); &#125; private static String order()&#123; Factory factory = new Factory(); return factory.prodLine(); &#125;&#125;//执行效果我订购并收到产品：产品A/*现因为市场需求改变增加,需要新加一条生产"产品B"的生产线, 但是资金有限。 只能再原有的生产线上增加功能(既可以生产A，又可以生产B)*/public class Factory &#123; public String prodLine(int type) &#123; if(type == 0)&#123; return "产品A"; &#125;else&#123; return "产品B"; &#125; &#125;&#125;/*当我们修改之后 会发现客户方有问题（订购不了产品） 因为什么！ 因为我们需要知道客户到底要什么产品(type)，客户没说，我们也不能做啊，不然做出来退货怎么办(出BUG)*/public class Client1 &#123; public static void main(String args[]) &#123; System.out.println("我订购并收到产品："+order()); &#125; private static String order()&#123; Factory factory = new Factory(); //客户申明要什么产品 return factory.prodLine(0); &#125;&#125;我订购并收到产品：产品A 以上只是最基本的开闭原则1234567891011121314151617181920212223242526272829303132//我们建厂之前需要提前写一个设计稿(接口)为未来做准备 比如 生产N种产品public interface IFactory &#123; String prodLine(int type);&#125;//现在市场上 出现了需要产品的客户 我们直接按照接口 建造工厂public class FactoryA implements IFactory&#123; @Override public String prodLine(int type) &#123; if(type == 0)&#123; return "产品A"; &#125;else&#123; return "产品B"; &#125; &#125;&#125;//客户方 没有变化 申明产品的类型public class Client1 &#123; public static void main(String args[]) &#123; System.out.println("我订购并收到产品："+order()); &#125; private static String order()&#123; Factory factory = new Factory(); //客户申明要什么产品 return factory.prodLine(0); &#125;&#125;我订购并收到产品：产品A/B]]></content>
  </entry>
  <entry>
    <title><![CDATA[Design Patterns of Java]]></title>
    <url>%2F2019%2F04%2F23%2FTwenty-three-design-patterns-of-Java%2F</url>
    <content type="text"><![CDATA[What is the design pattern?设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 百度设计模式概念 设计原则为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？面向对象有几个原则： 开闭原则（Open Closed Principle，OCP）、 单一职责原则（Single Responsiblity Principle SRP）、 里氏代换原则（Liskov Substitution Principle，LSP）、 依赖倒转原则（Dependency Inversion Principle，DIP）、 接口隔离原则（Interface Segregation Principle，ISP）、 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、 最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）。 开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。 设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的 百度设计模式设计原则]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo font table]]></title>
    <url>%2F2019%2F04%2F22%2FHexo%20font%20table%2F</url>
    <content type="text"><![CDATA[1，字体介绍这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 2，分级标题一级标题二级标题三级标题四级标题五级标题六级标题3，超链接写法： 行内形式：我的博客参考形式：[我的博客][1]，有一个很好的平台-[简书][2][1]:https://xfbxfbxfb.github.io/[2]:http://www.jianshu.com/ 4,列表无序列表：写法： 无序列表项1 无序列表项2 无序列表项3 有序列表：并不是真的自动排序写法： 1.1有序列表项1 3.3有序列表项4 2.2有序列表项3 6，表格 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo Code specification]]></title>
    <url>%2F2019%2F04%2F19%2FHexo%20Code%20specification%2F</url>
    <content type="text"><![CDATA[引用块在文章中插入引言，可包含作者、来源和标题。content 作者,来源原链接标题没有提供参数，则只输出普通的 blockquoteLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 引用书上的句子Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 引用 TwitterNEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用网络上的文章Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 代码块普通代码块12alert(&apos;Hello World!&apos;);alert(&apos;Hello World!&apos;);指定语言1[rectangle setX: 10 y: 10 width: 20 height: 20];附加说明Array.map1array.map(callback[, thisArg])附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3]另一种表现形式说明Underscore.js1alert('Hello World!') 在文章中插入获取的引用content 引用图添加一个内嵌页面iframe 在文章中插入指定大小的图片。插入图 文字链接 为何半夜母猪如此惨叫 段落 content]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
